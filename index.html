<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wishing Well Roof CAPTCHA</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            color: #333;
            flex-direction: column;
        }

        .captcha-container {
            background: #f0e6d2; 
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            width: 600px;
            border: 4px solid #5a4632;
        }

        h2 { margin-top: 0; color: #5a4632; letter-spacing: 1px; font-variant: small-caps; }
        p { color: #666; font-size: 0.9rem; margin-bottom: 15px; }

        canvas {
            border: 4px solid #5a4632;
            border-radius: 4px;
            cursor: pointer;
            display: block;
            margin: 0 auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }

        .status {
            margin-top: 15px;
            font-weight: bold;
            height: 24px;
            letter-spacing: 1px;
            font-family: monospace;
            font-size: 1.1rem;
        }
        .status.success { color: #27ae60; }
        .status.fail { color: #c0392b; }

        .noselect { user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body>

    <div class="captcha-container noselect">
        <h2>Humanity Verificare</h2>
        <p>Aim for the hole in the roof of the well.</p>
        
        <canvas id="gameCanvas" width="600" height="350"></canvas>
        
        <div id="statusMessage" class="status">Waiting...</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('statusMessage');

        // --- Configuration ---
        const GRAVITY = 0.5;
        const FRICTION = 0.99; 
        const BOUNCE_DAMPING = 0.4; 
        const CANVAS_H = 350;
        
        const CATAPULT_X_BASE = 60;
        const ARM_LENGTH = 80;

        const ANGLE_STOP = -1.4; 
        const ANGLE_GROUND = -3.0;
        const SWING_SPEED = 0.25;

        // --- Game State ---
        let isCharging = false;
        let isSwinging = false; 
        let isResetting = false; 
        let power = 0;
        let maxPower = 340; // Needs more power to clear the roof height
        let isVerified = false;
        
        // Dynamic positions
        let catapultY = 300;
        let wellY = 300;
        let pivotX, pivotY, stopBarX;
        let currentArmAngle = ANGLE_STOP; 

        // Well now has roof properties
        let well = { 
            x: 400, w: 60, h: 80, 
            roofH: 40, // Height of the roof peak
            roofOverhang: 10, // How far past the walls it goes
            holeWidth: 20, // The gap at the top
            leftGrain: [], rightGrain: []
        }; 

        let stone = {
            x: 0, y: 0, vx: 0, vy: 0, radius: 10, mass: 1, angle: 0, angVel: 0, isFlying: false, points: [] 
        };

        function init() {
            setupRound();
            loop();
        }

        function setupRound() {
            catapultY = Math.floor(Math.random() * 120) + 200;
            wellY = Math.floor(Math.random() * 100) + 220; // Ensure well isn't too high or roof clips

            pivotX = CATAPULT_X_BASE + 40;
            pivotY = catapultY - 20;
            stopBarX = pivotX + 20;

            stone.radius = Math.floor(Math.random() * 10) + 10;
            stone.mass = (stone.radius * stone.radius) / 90; 
            stone.isFlying = false;
            stone.vx = 0; stone.vy = 0;
            
            currentArmAngle = ANGLE_STOP;
            
            generateJaggedStone();
            randomizeWell();
            
            updateStonePositionToArm();
        }

        function updateStonePositionToArm() {
            stone.angle = currentArmAngle;
            stone.x = pivotX + Math.cos(currentArmAngle) * ARM_LENGTH;
            stone.y = pivotY + Math.sin(currentArmAngle) * ARM_LENGTH;
        }

        function generateJaggedStone() {
            stone.points = [];
            const sides = 5 + Math.floor(Math.random() * 4);
            const bulgeAngle = Math.random() * Math.PI * 2;
            let currentAngle = 0;
            for (let i = 0; i < sides; i++) {
                const slice = (Math.PI * 2) / sides;
                currentAngle += slice * (0.8 + Math.random() * 0.4);
                if (i === sides - 1) currentAngle = Math.PI * 2; 
                let r = stone.radius * (0.8 + Math.random() * 0.3);
                const angleDiff = Math.abs(currentAngle - bulgeAngle);
                if (angleDiff < 1.0) r *= 1.3; 
                stone.points.push({ x: Math.cos(currentAngle) * r, y: Math.sin(currentAngle) * r });
            }
        }

        function generateGrainPattern(width) {
            let lines = [];
            for(let i = 3; i < width; i += 5 + Math.random()*5) {
                lines.push(i);
            }
            return lines;
        }

        function randomizeWell() {
            const minX = 380;
            const maxX = 500;
            well.x = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
            well.h = 60; // Lower wall height to make room for roof
            
            // Roof Geometry
            well.roofH = Math.floor(Math.random() * 15) + 35; // 35-50px tall
            well.roofOverhang = 15;
            
            // Hole Calculation
            const innerSlack = Math.random() * 6 + 6; // Needs a bit more slack for roof shots
            well.holeWidth = (stone.radius * 2) + innerSlack;
            
            // Wall width is hole width + some thickness for the roof slope visual
            // But realistically, the well shaft is usually uniform.
            // Let's make the well shaft slightly wider than the hole
            well.w = well.holeWidth + 20; 

            well.leftGrain = generateGrainPattern(15);
            well.rightGrain = generateGrainPattern(15);
        }

        function resetGame() {
            isResetting = false;
            power = 0;
            isCharging = false;
            isSwinging = false;
            setupRound();
        }

        // --- Input ---
        const startCharge = () => { if (stone.isFlying || isVerified || isResetting || isSwinging) return; isCharging = true; statusEl.innerText = "Cranking..."; statusEl.className = "status"; };
        const releaseCharge = () => { if (!isCharging || isVerified || isResetting || isSwinging) return; isCharging = false; startSwing(); };
        canvas.addEventListener('mousedown', startCharge);
        canvas.addEventListener('mouseup', releaseCharge);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startCharge(); });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); releaseCharge(); });

        function startSwing() { isSwinging = true; statusEl.innerText = "Firing!"; }

        function launchStone() {
            isSwinging = false;
            stone.isFlying = true;
            currentArmAngle = ANGLE_STOP; 
            updateStonePositionToArm();

            // Higher arc needed for roof
            const launchAngle = -70 * (Math.PI / 180); 
            const torsionForce = power * 0.45; 
            const velocityMagnitude = torsionForce / stone.mass;
            const wobble = (Math.random() - 0.5) * 0.2; 
            
            stone.vx = velocityMagnitude * Math.cos(launchAngle + wobble);
            stone.vy = velocityMagnitude * Math.sin(launchAngle + wobble); 
            stone.angVel = ((Math.random() * 0.8) - 0.4) / stone.mass;
            statusEl.innerText = "Loose!";
        }

        // --- Physics ---
        function checkRectCollision(rectX, rectY, rectW, rectH) {
            let closestX = Math.max(rectX, Math.min(stone.x, rectX + rectW));
            let closestY = Math.max(rectY, Math.min(stone.y, rectY + rectH));
            let dx = stone.x - closestX; let dy = stone.y - closestY;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < stone.radius) {
                let nx = dx / distance; let ny = dy / distance;
                if (distance === 0) { nx = 0; ny = -1; }
                let depth = stone.radius - distance;
                stone.x += nx * depth; stone.y += ny * depth;
                let dot = stone.vx * nx + stone.vy * ny;
                let massDamping = BOUNCE_DAMPING / Math.sqrt(stone.mass);
                stone.vx = (stone.vx - 2 * dot * nx) * massDamping;
                stone.vy = (stone.vy - 2 * dot * ny) * massDamping;
                stone.angVel += (stone.vx * 0.1); 
                return true;
            }
            return false;
        }

        function checkLineCollision(x1, y1, x2, y2) {
            const lx = x2 - x1; const ly = y2 - y1;
            const lenSq = lx*lx + ly*ly;
            let t = ((stone.x - x1) * lx + (stone.y - y1) * ly) / lenSq;
            t = Math.max(0, Math.min(1, t));
            const cx = x1 + t * lx; const cy = y1 + t * ly;
            const dx = stone.x - cx; const dy = stone.y - cy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < stone.radius) {
                let nx = dx / dist; let ny = dy / dist;
                if (dist === 0) { nx = 0; ny = -1; }
                const overlap = stone.radius - dist;
                stone.x += nx * overlap; stone.y += ny * overlap;
                const dot = stone.vx * nx + stone.vy * ny;
                
                // Roofs are bouncy to reject stones
                const roofDamping = 0.7; 
                stone.vx = (stone.vx - 2 * dot * nx) * roofDamping;
                stone.vy = (stone.vy - 2 * dot * ny) * roofDamping;
                stone.angVel += (stone.vx * -ny + stone.vy * nx) * 0.1;
                return true;
            }
            return false;
        }

        function update() {
            if (isVerified || isResetting) return;

            if (isCharging) {
                power += 3.5; if (power > maxPower) power = maxPower; 
                const pct = power/maxPower;
                currentArmAngle = ANGLE_STOP + (pct * (ANGLE_GROUND - ANGLE_STOP));
                updateStonePositionToArm();
            }

            if (isSwinging) {
                currentArmAngle += SWING_SPEED; 
                if (currentArmAngle >= ANGLE_STOP) {
                    currentArmAngle = ANGLE_STOP;
                    launchStone(); 
                }
                updateStonePositionToArm();
            }

            if (stone.isFlying) {
                stone.vy += GRAVITY; stone.vx *= FRICTION;
                stone.x += stone.vx; stone.y += stone.vy; stone.angle += stone.angVel;

                const wellTop = wellY - well.h;
                const supportH = 20; // Height of supports above wall
                const roofBottomY = wellTop - supportH;
                const roofPeakY = roofBottomY - well.roofH;
                const center = well.x + well.w / 2;
                
                // 1. Walls
                checkRectCollision(well.x - 15, wellTop, 15, well.h);
                checkRectCollision(well.x + well.w, wellTop, 15, well.h);

                // 2. ROOF COLLISION
                // Left Roof Panel: From (Left Overhang) -> (Center - Hole/2)
                // Bottom-Left of roof: well.x - overhang
                const roofLeftX = well.x - well.roofOverhang;
                const holeLeftX = center - well.holeWidth / 2;
                checkLineCollision(roofLeftX, roofBottomY, holeLeftX, roofPeakY);

                // Right Roof Panel: From (Right Overhang) -> (Center + Hole/2)
                const roofRightX = well.x + well.w + well.roofOverhang;
                const holeRightX = center + well.holeWidth / 2;
                checkLineCollision(roofRightX, roofBottomY, holeRightX, roofPeakY);

                // 3. Terrain Checks
                if (stone.x < well.x && stone.y + stone.radius > catapultY + 10) {
                     stone.y = catapultY + 10 - stone.radius;
                     fail("HIT TERRAIN"); return;
                }
                
                // 4. Ground Fail (must be inside well shaft)
                if (stone.y + stone.radius >= wellY) {
                    // It must be between walls
                    if (stone.x < well.x + 5 || stone.x > well.x + well.w - 5) {
                        stone.y = wellY - stone.radius;
                        fail("REJECTED"); return;
                    }
                }
                
                // 5. Stuck/Win
                if (Math.abs(stone.vx) < 0.1 && Math.abs(stone.vy) < 0.1) {
                    if (stone.y < roofPeakY) { stone.vx += (Math.random() > 0.5 ? 2 : -2); stone.vy -= 2; } // Stuck on roof? Slide off
                    if (stone.y < wellY - stone.radius - 20) { fail("JAMMED"); return; }
                }
                
                if (stone.y + stone.radius >= wellY) {
                     stone.y = wellY - stone.radius;
                     stone.vy = -stone.vy * 0.1; stone.vx *= 0.5; 
                     if (Math.abs(stone.vx) < 0.1 && Math.abs(stone.vy) < 0.5) verifySuccess();
                }
                
                if (stone.x > canvas.width + 50 || stone.y > CANVAS_H + 100) fail("MISSED");
            }
        }

        function fail(msg) {
            if(isResetting) return; isResetting = true; stone.isFlying = false; 
            statusEl.innerText = msg; statusEl.className = "status fail";
            setTimeout(() => { resetGame(); statusEl.innerText = "Again."; statusEl.className = "status"; }, 1000);
        }

        function verifySuccess() {
            isVerified = true; statusEl.innerText = "HUMAN VERIFIED"; statusEl.className = "status success"; stone.isFlying = false;
        }

        function drawWoodRect(x, y, w, h, baseColor, grainColor, grainPattern) {
            ctx.fillStyle = baseColor; ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = grainColor; ctx.lineWidth = 1; ctx.beginPath();
            if(grainPattern) {
                for(let offset of grainPattern) {
                    ctx.moveTo(x + offset, y); ctx.lineTo(x + offset, y + h);
                }
            }
            ctx.stroke();
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 2; ctx.strokeRect(x,y,w,h);
        }

        // --- Rendering ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, CANVAS_H);

            let skyGrd = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
            skyGrd.addColorStop(0, "#4FA4FF"); skyGrd.addColorStop(1, "#B0E0E6");
            ctx.fillStyle = skyGrd; ctx.fillRect(0,0, canvas.width, CANVAS_H);

            ctx.fillStyle = "#6aa35b"; 
            ctx.beginPath(); ctx.moveTo(0, Math.min(catapultY, wellY) - 30);
            ctx.bezierCurveTo(150, Math.min(catapultY, wellY) - 100, 400, Math.max(catapultY, wellY) - 50, 600, Math.min(catapultY, wellY) - 20);
            ctx.lineTo(600, CANVAS_H); ctx.lineTo(0, CANVAS_H); ctx.fill();

            let groundGrd = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
            groundGrd.addColorStop(0, "#567d46"); groundGrd.addColorStop(1, "#3e5c32");
            ctx.fillStyle = groundGrd; 
            ctx.beginPath();
            ctx.moveTo(0, catapultY);
            const midX = (CATAPULT_X_BASE + well.x) / 2;
            ctx.bezierCurveTo(midX - 50, catapultY, midX + 50, wellY, well.x, wellY);
            ctx.lineTo(canvas.width, wellY + 20);
            ctx.lineTo(canvas.width, CANVAS_H); ctx.lineTo(0, CANVAS_H);
            ctx.closePath();
            ctx.fill();

            const wellTop = wellY - well.h;
            
            // --- DRAW WOODEN WELL ---
            const woodBase = '#a07048'; const woodGrain = '#704a2e';
            
            ctx.fillStyle = '#2a1e14'; ctx.fillRect(well.x, wellTop, well.w, well.h);
            ctx.fillStyle = 'rgba(41, 128, 185, 0.6)'; 
            const waterHeight = 30; ctx.fillRect(well.x, wellY - waterHeight, well.w, waterHeight);

            drawWoodRect(well.x - 15, wellTop, 15, well.h, woodBase, woodGrain, well.leftGrain);
            drawWoodRect(well.x + well.w, wellTop, 15, well.h, woodBase, woodGrain, well.rightGrain);
            
            // Supports
            const supportH = 20;
            const roofBottomY = wellTop - supportH;
            ctx.fillStyle = '#4a3627'; // Dark wood
            ctx.fillRect(well.x, wellTop - supportH, 8, supportH); // Left support
            ctx.fillRect(well.x + well.w - 8, wellTop - supportH, 8, supportH); // Right support

            // ROOF
            const roofPeakY = roofBottomY - well.roofH;
            const roofLeftX = well.x - well.roofOverhang;
            const roofRightX = well.x + well.w + well.roofOverhang;
            const center = well.x + well.w / 2;
            const holeLeftX = center - well.holeWidth / 2;
            const holeRightX = center + well.holeWidth / 2;

            ctx.fillStyle = '#6b4423'; ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 2;
            
            // Left Roof Panel
            ctx.beginPath();
            ctx.moveTo(roofLeftX, roofBottomY + 10); // Eave
            ctx.lineTo(holeLeftX, roofPeakY); // Peak
            ctx.lineTo(holeLeftX - 5, roofPeakY + 10); // Thickness inner
            ctx.lineTo(roofLeftX, roofBottomY + 20); // Thickness outer
            ctx.closePath();
            ctx.fill(); ctx.stroke();

            // Right Roof Panel
            ctx.beginPath();
            ctx.moveTo(roofRightX, roofBottomY + 10); // Eave
            ctx.lineTo(holeRightX, roofPeakY); // Peak
            ctx.lineTo(holeRightX + 5, roofPeakY + 10); // Thickness inner
            ctx.lineTo(roofRightX, roofBottomY + 20); // Thickness outer
            ctx.closePath();
            ctx.fill(); ctx.stroke();


            // --- DRAW CATAPULT ---
            ctx.lineWidth = 6; ctx.strokeStyle = '#5a4632'; ctx.fillStyle = '#5a4632';
            ctx.fillRect(CATAPULT_X_BASE, catapultY - 10, 80, 10); 
            ctx.fillRect(stopBarX, catapultY - 90, 8, 90); 
            ctx.beginPath(); ctx.moveTo(stopBarX, catapultY - 70); ctx.lineTo(pivotX - 20, catapultY - 10); ctx.stroke();

            ctx.save(); ctx.translate(pivotX, pivotY);
            ctx.rotate(currentArmAngle);
            ctx.fillStyle = '#8e7150'; ctx.fillRect(0, -6, ARM_LENGTH, 12);
            ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.arc(ARM_LENGTH, 0, 14, 0, Math.PI*2); ctx.fill();

            if (!stone.isFlying) {
                ctx.save(); ctx.translate(ARM_LENGTH, 0); renderStoneShape(0, 0); ctx.restore();
            }
            ctx.restore(); 

            if (isCharging) {
                ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2; ctx.beginPath();
                const tipX = pivotX + Math.cos(currentArmAngle) * ARM_LENGTH;
                const tipY = pivotY + Math.sin(currentArmAngle) * ARM_LENGTH;
                ctx.moveTo(tipX, tipY); ctx.lineTo(pivotX - 50, catapultY); ctx.stroke();
            }

            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(pivotX, pivotY, 6, 0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.arc(pivotX - 30, catapultY, 12, 0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.arc(pivotX + 30, catapultY, 12, 0, Math.PI*2); ctx.fill(); 

            if (stone.isFlying) {
                ctx.save(); ctx.translate(stone.x, stone.y); ctx.rotate(stone.angle);
                renderStoneShape(0, 0); ctx.restore();
            }
        }

        function renderStoneShape(lx, ly) {
            let lightness = 60 - (stone.mass * 8); 
            ctx.fillStyle = `hsl(30, 10%, ${lightness}%)`; ctx.strokeStyle = '#2c1e14'; ctx.lineWidth = 2;
            ctx.beginPath();
            if (stone.points.length > 0) {
                ctx.moveTo(lx + stone.points[0].x, ly + stone.points[0].y);
                for (let i = 1; i < stone.points.length; i++) {
                    ctx.lineTo(lx + stone.points[i].x, ly + stone.points[i].y);
                }
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
        init();
    </script>
</body>
</html>
